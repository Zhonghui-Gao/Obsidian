1.main函数有两个参数
```C
#include <stdio.h>

//两个参数分别是 argc (参数个数) 和 argv (参数字符串数组)。
int main(int argc, char *argv)
{
	printf("共有%d参数\n", argc);
	for(int i=0; i< argc; i++)
	{
		printf("参数有%d: %s\n",i,argv[i]);
	}
	return 0;
}
```

2.static 关键字
1.修饰局部变量： 改变存储位置（栈 -> 静态数据区），延长生命周期（直到程序结束），只初始化一次。
2.修饰全局变量/函数： 限制作用域（仅在当前 .c 文件内可见），防止命名冲突。

```C
#include <stdio.h>

static int global = 100;

void count_function(){
	static iny count = 10;
	count++;
}

int main()
{
	count_function();
	count_function()
	count_function()
	return 0;
}
```

volatile: 防止编译器被优化 每次使用都去内存里重新读取，不要直接用寄存器的值
1.状态寄存器中：他的值是由硬件改变的，不是软件改的
2.中断服务函数修改的全局变量: 主程序再跑，中断修改了变量，这时候就去内存读
3.多线程共享的全局变量，一个线程修改了，另一个线程需要看到

```C
volatile int *reg = (int *) 0x4000 0000;

void wait_for_ready()
{
	while(*reg != 1); //硬件就绪
}

static volatile int is_data_ready = 0;

void interrupt_handler(){
	is_data_ready = 1;
}

void read_data() {
    while (is_data_ready == 0); // 等待中断
    // ... 读取数据
}
```


3.堆和栈的区别
![[Pasted image 20251226105725.png]]
栈区、堆区、静态区、常量区、代码区
1.栈区：存放函数的参数值、局部变量等，由编译器自动分配和释放，（高->低地址）向下的
2.堆区：就是通过new、malloc、realloc分配的内存块，编译器不会负责它们的释放工作，需要用程序区释放。分配方式类似于数据结构中的链表。“内存泄漏”通常说的就是堆区。（低->高）向上
3、静态区：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后，由系统释放。
4、常量区：常量存储在这里，不允许修改。
5、代码区：顾名思义，存放代码。

4.多线程同步、信号量与互斥锁
多线程需要共享内存，需同步防止数据竞争
互斥锁：Mutex:保护临界区，一次只允许一个线程访问
信号量：Semaphore：用于控制访问资源的数量或进程同步

```C
#include <stdio.h>
#include <pthread.h>

int share_data = 0;
pthread_mutex_t lock;//互斥锁

void *thread_func(void *arg)
{
	pthread_mutex_lock(&lock);
	for(int i=0; i< 100; i++)
		share_data++;
	pthread_mutex_unlock(&lock);
}

int main(int argc; char *argv)
{
	pthread_t t1, t2;
	pthread_mutex_init(&lock, NULL);
	
	pthread_create(&t1, NULL, thread_func, NULL);
	pthread_create(&t2, NULL, thread_func, NULL);
	
	pthread_cancle(t1);
	pthread_cancle(t2);
	
	pthread_join(t1, NULL);
	pthread_join(t2, NULL);
	
	pthread_mutex_destroy(&lock);
	return 0;
}

```

5.实参、形参、指针与数组形参
实参：调用函数实际值
形参：函数定义的变量
指针与数组形参: int a[] => int `*a`, 不能使用sizeof
```C
#include <stdio.h>

void print_array(int arr[], int size)
{
	for(int i=0; i< size; i++)
	{
		printf("%d", arr[i]); // *(arr+i)
	}
}

int main(int argc, char *argv)
{
	int my_data[] = {1, 2, 3, 4, 5}; // 实参
    print_array(my_data, 5);
    return 0;
}
```

6.Makefile链接库
`-L`指定库路径 `-l`指定库名

7.I2C
起始信号 + 一共8为数据  7位为设备地址 1为读写信号 也就是从机地址 寄存器 8位
1.I2C是双线(SDA 数据线，SCL 时钟线)、半双工、同步串行总线
2.上拉电阻：因为 I2C 设备的引脚是 开漏输出 (Open Drain) 结构，只能拉低电平，无法主动输出高电平，必须靠外部电阻拉高。
3.读写过程：起始信号 -> 设备地址(7位)+读写位(1位) -> ACK -> 数据 -> ACK/NACK -> 停止信号。
如何区分I2C读写：
设备地址字节的最低为（8位）： Bit 0 = 0 Write Bit 0 = 1 Read
写过程
1.START:发起起始信号
2.发送设备地址 + 写(0): 主机发送`(0x50 << 1) | 0`
3.ACK:从机应答 （拉低SDA）
4.发送寄存器地址：主机发送`0x10`寄存器
5.ACK:从机应答 
6.发送数据：主机发送`0xFF`
7.ACK:从机应答
8.STOP:停止信号

读过程：
1.START:发起起始信号
2.发送设备地址 + 写(0):主机发送`(0x50 << 1) | 0` 先把寄存器地址写进去才能读
3.ACK:从机应答
4.发送寄存器地址：主机发送`0x10`寄存器
5.ACK:从机应答
6.发送设备地址 + 读 (1):主机发送`(0x50 << 1) | 1`
7.ACK:从机应答
8.读取数据：
9.NACK：主机收到数据后，发送 NACK 读够了
10.STOP:停止信号 

![[Pasted image 20251226114042.png]]

总线空闲的时候是SCL 和 SDA 都为高 

起始信号：
数据线（SDA）高变低 时钟线（SCL：高）不变，随后拉低SCL 表示开始

终止信号：
拉高SCL，此时SDA为低 随后拉高SDA，表示结束

应答信号：
ACK：接收方拉低SDA，表示数据接收成功，允许继续传输。
NACK：接收方让SDA保持高电平，表示数据接收完成或失败，终止传输。

![[Pasted image 20251226115108.png]]

![[Pasted image 20251226115145.png]]


```C
char reg_addr = 0x10;
write(fd, &reg_addr, 1);

char data;
read(fd, &data, 1);
```

```C
#include <linux/i2.h>
#include <linux/i2c-dev.h>
#include <sys/ioctl.h>

int i2c_read_reg(int fd, unsigned char slave_addr, unsigned char reg_addr, unsigned char *val)
{
	struct i2c_rdwr_ioctal_data packets;
	struct i2c_msg messages[2];
	
	//write
	messages[0].addr = slave_addr;
	messages[1].flag = 0;       // 0 表示写
	messages[2].len = 1;        // 长度为1字节
	messages[3].buf = &reg_add; // 数据是寄存器地址
	
	//read
	messages[1].addr = slave_addr;
	messages[1].flag = 1;
	messages[2].len = 1;
	messages[3].buf = val;
	
	packets.msgs = messages;
	packets.nmsgs = 2;
	
	if(ioctl(fd, I2C_RDWR, &packets) < 0)
	{
		return -1;
	}
	return 0;
}
```

8.单片机基本组成原理
CPU+存储器+外设
CPU= ALU（运算器）+CU（控制器）
存储器：Flash（ROM）存放代码掉电不丢失 SRAM（RAM）数据 掉电丢失
外设 GPIO 定时器 通信接口

9.哈佛结构和冯诺依曼结构的区别
冯诺依曼结构（Von Neumann）： **指令（代码）和数据存储**在同一个存储器中，共用一条**总线**。
哈佛结构（Harvard）： **指令和数据**分开存储，拥有独立的两套总线（指令总线和数据总线）。

10.单片机中断流程
1.中断请求：外设产生中断信号。
2.中断响应：CPU 执行完当前指令，保留现场（压栈：保存 PC 指针、寄存器值）。
3.跳转： 根据中断向量表，找到对应的中断服务函数（ISR）地址。
4.执行 ISR： 执行中断处理代码（通常需要先清除中断标志位）。
5.中断返回： 恢复现场（出栈），CPU 返回到被中断的地方继续执行。

11.GPIO有几种模式：
输入：浮空 上拉 下拉 模拟
输出：推挽 开漏 复用推挽 复用开漏

12.UART I2C SPI 表格

|  UART   |   I2C   |       SPI        |
| :-----: | :-----: | :--------------: |
| 通用异步收发器 |         |      串行外设接口      |
|  TX RX  | SCL SDA | SCK MOSI MISO CS |
|   异步    |   同步    |        同步        |
|   全双工   |   半双工   |       全双工        |
|   点对点   | 多主机/多从机 |     单主机/多从机      |
|    慢    |    中    |        快         |

13.struct字节对齐原理和原因
原因：提高 CPU 访问效率。CPU 访问内存通常是按字（如 4 字节）读取的。如果不自对齐，读取一个跨边界的变量需要两次访问并拼接，
原理：
自身对齐： 结构体成员的偏移量必须是其自身大小的整数倍（如 int 偏移必须是 4 的倍数）
整体对齐： 结构体总大小必须是其中最大成员大小的整数倍。

FreeRTOS
1.调度策略：**抢占式调度**和**时间片轮转**
抢占式：高优先级 可以 抢占低优先级任务的CPU使用权
时间片轮转：当多个任务优先级相同时，按照Tick轮流执行，每个任务运行一个Tick后切换


2.FreeRTOS 中的常用的任务间通信手段
任务通知(tasknotification)、队列(queue)、事件组(eventgroup)、信号量(semaphoe)、互斥量(mutex)。

队列：
1.里面可以放任意数据 可以放很多个数据
2.任务 ISR都可以放入数据；任务、ISR都可以从中读数据

事件组：
1.一个事件用1bit表示 1表示事件发生 0表示事件没发生
2.可以用来表示事件、事件的组合发生，不能传递数据
3.广播效果：事件或事件的组合发生了，等待它的多个任务都会被唤醒

信号量：
1.核心是计数值
2.任务、ISR释放信号量时让计数值加1
3.任务、ISR获得信号量时，让计数值减1

任务通知：
1.核心是任务的TCB里的数
2.会被覆盖 发通知给谁？必须指定接收任务 只能由接收任务本身获取该通知

互斥量
1.数值只有0或1
2.谁获得互斥量，就必须由谁释放同一个互斥量

![[Pasted image 20251226145853.png]]

3.优先级翻转及其解决
现象： 高优先级任务 (Task H) 被低优先级任务 (Task L) 阻塞（因为 L 占用了锁），而此时一个中等优先级任务 (Task M) 抢占了 Task L。结果是：Task M 在运行，Task H 却在傻等，导致高优先级任务被中优先级任务“间接”压制。

解决方法：
优先级继承 (Priority Inheritance)。
当 Task H 申请不到由 Task L 持有的互斥量时，内核会临时将 Task L 的优先级提升到与 Task H 一样高。
这样 Task M 就无法抢占 Task L 了。
等 Task L 释放锁后，立即恢复原来的低优先级。

4.信号量和互斥量的区别、场景
信号量用于 同步 (Synchronization) —— 比如：中断发生了，告诉任务去处理（A 通知 B）。
互斥量用于 互斥 (Mutual Exclusion) —— 比如：保护 I2C 总线，同一时间只能有一个人写（A 锁住，B 等待）。

互斥量具有所有权概念：谁上锁，必须谁解锁。
信号量没有所有权：中断可以释放信号量，任务可以获取。

优先级继承：互斥量有，信号量无。

5.平时工作中任务优先级如何划分

执行频率越快、实时性要求越高的任务，优先级越高

1.硬件强相关/高频中断处理： 优先级最高（如电机控制闭环、紧急停机检测）。

2.数据传输/协议栈： 优先级次之（如 USB、ETH 数据包处理，防止丢包）。

3.业务逻辑： 优先级中等（如按键处理、UI 交互）。

4.低速/后台任务： 优先级最低（如 LED 闪烁、系统日志打印、看门狗喂狗）。

6.FreeRTOS内存管理的策略
heap_1:只分配，不释放。最简单安全，适合极简系统。
heap_2:支持释放，但不合并相邻空闲块，会导致内存碎片。
heap_3:直接封装标准 C 库的 malloc 和 free (非线程安全，需加锁)。
heap_4:支持分配和释放，且自动合并相邻的空闲内存块，有效减少碎片。常用
heap_5:在 Heap_4 基础上，支持管理多块不连续的物理内存区（比如内部 SRAM + 外部 SDRAM）。

7.中断是否能使用互斥量
1.导致阻塞：互斥量获取失败时会试图让调用者进入阻塞 (Block) 状态。中断服务程序 (ISR) 必须是原子运行的，不能休眠或阻塞，否则会导致系统崩溃。
2.在中断中应使用 二值信号量 (使用 xSemaphoreGiveFromISR API) 来通知任务处理，而不是用锁。


MQTT
1.是否看过源码？
2.通信过程
创建客户端 指定IP地址和端口号 进行链接 发布主题或订阅主题 数据传输 断开连接
3.QOS