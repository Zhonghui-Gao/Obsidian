1.main函数有两个参数
```C
#include <stdio.h>

//两个参数分别是 argc (参数个数) 和 argv (参数字符串数组)。
int main(int argc, char *argv)
{
	printf("共有%d参数\n", argc);
	for(int i=0; i< argc; i++)
	{
		printf("参数有%d: %s\n",i,argv[i]);
	}
	return 0;
}
```

2.static 关键字
1.修饰局部变量： 改变存储位置（栈 -> 静态数据区），延长生命周期（直到程序结束），只初始化一次。
2.修饰全局变量/函数： 限制作用域（仅在当前 .c 文件内可见），防止命名冲突。

```C
#include <stdio.h>

static int global = 100;

void count_function(){
	static iny count = 10;
	count++;
}

int main()
{
	count_function();
	count_function()
	count_function()
	return 0;
}
```

volatile: 防止编译器被优化 每次使用都去内存里重新读取，不要直接用寄存器的值
1.状态寄存器中：他的值是由硬件改变的，不是软件改的
2.中断服务函数修改的全局变量: 主程序再跑，中断修改了变量，这时候就去内存读
3.多线程共享的全局变量，一个线程修改了，另一个线程需要看到

```C
volatile int *reg = (int *) 0x4000 0000;

void wait_for_ready()
{
	while(*reg != 1); //硬件就绪
}

static volatile int is_data_ready = 0;

void interrupt_handler(){
	is_data_ready = 1;
}

void read_data() {
    while (is_data_ready == 0); // 等待中断
    // ... 读取数据
}
```


3.堆和栈的区别
![[Pasted image 20251226105725.png]]
栈区、堆区、静态区、常量区、代码区
1.栈区：存放函数的参数值、局部变量等，由编译器自动分配和释放，（高->低地址）向下的
2.堆区：就是通过new、malloc、realloc分配的内存块，编译器不会负责它们的释放工作，需要用程序区释放。分配方式类似于数据结构中的链表。“内存泄漏”通常说的就是堆区。（低->高）向上
3、静态区：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后，由系统释放。
4、常量区：常量存储在这里，不允许修改。
5、代码区：顾名思义，存放代码。

4.多线程同步、信号量与互斥锁
多线程需要共享内存，需同步防止数据竞争
互斥锁：Mutex:保护临界区，一次只允许一个线程访问
信号量：Semaphore：用于控制访问资源的数量或进程同步

```C
#include <stdio.h>
#include <pthread.h>

int share_data = 0;
pthread_mutex_t lock;//互斥锁

void *thread_func(void *arg)
{
	pthread_mutex_lock(&lock);
	for(int i=0; i< 100; i++)
		share_data++;
	pthread_mutex_unlock(&lock);
}

int main(int argc; char *argv)
{
	pthread_t t1, t2;
	pthread_mutex_init(&lock, NULL);
	
	pthread_create(&t1, NULL, thread_func, NULL);
	pthread_create(&t2, NULL, thread_func, NULL);
	
	pthread_cancle(t1);
	pthread_cancle(t2);
	
	pthread_join(t1, NULL);
	pthread_join(t2, NULL);
	
	pthread_mutex_destroy(&lock);
	return 0;
}

```

5.实参、形参、指针与数组形参
实参：调用函数实际值
形参：函数定义的变量
指针与数组形参: int a[] => int `*a`, 不能使用sizeof
```C
#include <stdio.h>

void print_array(int arr[], int size)
{
	for(int i=0; i< size; i++)
	{
		printf("%d", arr[i]); // *(arr+i)
	}
}

int main(int argc, char *argv)
{
	int my_data[] = {1, 2, 3, 4, 5}; // 实参
    print_array(my_data, 5);
    return 0;
}
```

6.Makefile链接库
`-L`指定库路径 `-l`指定库名

7.I2C
起始信号 + 一共8为数据  7位为设备地址 1为读写信号 也就是从机地址 寄存器 8位
1.I2C是双线(SDA 数据线，SCL 时钟线)、半双工、同步串行总线
2.上拉电阻：因为 I2C 设备的引脚是 开漏输出 (Open Drain) 结构，只能拉低电平，无法主动输出高电平，必须靠外部电阻拉高。
3.读写过程：起始信号 -> 设备地址(7位)+读写位(1位) -> ACK -> 数据 -> ACK/NACK -> 停止信号。
如何区分I2C读写：
设备地址字节的最低为（8位）： Bit 0 = 0 Write Bit 0 = 1 Read
写过程
1.START:发起起始信号
2.发送设备地址 + 写(0): 主机发送`(0x50 << 1) | 0`
3.ACK:从机应答 （拉低SDA）
4.发送寄存器地址：主机发送`0x10`寄存器
5.ACK:从机应答 
6.发送数据：主机发送`0xFF`
7.ACK:从机应答
8.STOP:停止信号

读过程：
1.START:发起起始信号
2.发送设备地址 + 写(0):主机发送`(0x50 << 1) | 0` 先把寄存器地址写进去才能读
3.ACK:从机应答
4.发送寄存器地址：主机发送`0x10`寄存器
5.ACK:从机应答
6.发送设备地址 + 读 (1):主机发送`(0x50 << 1) | 1`
7.ACK:从机应答
8.读取数据：
9.NACK：主机收到数据后，发送 NACK 读够了
10.STOP:停止信号 

![[Pasted image 20251226114042.png]]

总线空闲的时候是SCL 和 SDA 都为高 

起始信号：
数据线（SDA）高变低 时钟线（SCL：高）不变，随后拉低SCL 表示开始

终止信号：
拉高SCL，此时SDA为低 随后拉高SDA，表示结束

应答信号：
ACK：接收方拉低SDA，表示数据接收成功，允许继续传输。
NACK：接收方让SDA保持高电平，表示数据接收完成或失败，终止传输。

![[Pasted image 20251226115108.png]]

![[Pasted image 20251226115145.png]]


```C
char reg_addr = 0x10;
write(fd, &reg_addr, 1);

char data;
read(fd, &data, 1);
```

```C
#include <linux/i2.h>
#include <linux/i2c-dev.h>
#include <sys/ioctl.h>

int i2c_read_reg(int fd, unsigned char slave_addr, unsigned char reg_addr, unsigned char *val)
{
	struct i2c_rdwr_ioctal_data packets;
	struct i2c_msg messages[2];
	
	//write
	messages[0].addr = slave_addr;
	messages[1].flag = 0;       // 0 表示写
	messages[2].len = 1;        // 长度为1字节
	messages[3].buf = &reg_add; // 数据是寄存器地址
	
	//read
	messages[1].addr = slave_addr;
	messages[1].flag = 1;
	messages[2].len = 1;
	messages[3].buf = val;
	
	packets.msgs = messages;
	packets.nmsgs = 2;
	
	if(ioctl(fd, I2C_RDWR, &packets) < 0)
	{
		return -1;
	}
	return 0;
}
```

8.单片机基本组成原理
CPU+存储器+外设
CPU= ALU（运算器）+CU（控制器）
存储器：Flash（ROM）存放代码掉电不丢失 SRAM（RAM）数据 掉电丢失
外设 GPIO 定时器 通信接口

9.哈佛结构和冯诺依曼结构的区别
冯诺依曼结构（Von Neumann）： **指令（代码）和数据存储**在同一个存储器中，共用一条**总线**。
哈佛结构（Harvard）： **指令和数据**分开存储，拥有独立的两套总线（指令总线和数据总线）。

10.单片机中断流程
1.中断请求：外设产生中断信号。
2.中断响应：CPU 执行完当前指令，保留现场（压栈：保存 PC 指针、寄存器值）。
3.跳转： 根据中断向量表，找到对应的中断服务函数（ISR）地址。
4.执行 ISR： 执行中断处理代码（通常需要先清除中断标志位）。
5.中断返回： 恢复现场（出栈），CPU 返回到被中断的地方继续执行。

11.GPIO有几种模式：
输入：浮空 上拉 下拉 模拟
输出：推挽 开漏 复用推挽 复用开漏

12.UART I2C SPI 表格

|  UART   |   I2C   |       SPI        |
| :-----: | :-----: | :--------------: |
| 通用异步收发器 |         |      串行外设接口      |
|  TX RX  | SCL SDA | SCK MOSI MISO CS |
|   异步    |   同步    |        同步        |
|   全双工   |   半双工   |       全双工        |
|   点对点   | 多主机/多从机 |     单主机/多从机      |
|    慢    |    中    |        快         |

13.struct字节对齐原理和原因
原因：提高 CPU 访问效率。CPU 访问内存通常是按字（如 4 字节）读取的。如果不自对齐，读取一个跨边界的变量需要两次访问并拼接，
原理：
自身对齐： 结构体成员的偏移量必须是其自身大小的整数倍（如 int 偏移必须是 4 的倍数）
整体对齐： 结构体总大小必须是其中最大成员大小的整数倍。

FreeRTOS
调度策略：**抢占式调度**和**时间片轮转**
抢占式：高优先级 可以 抢占低优先级任务的CPU使用权
时间片轮转：当多个任务优先级相同时，按照Tick轮流执行，每个任务运行一个Tick后切换

