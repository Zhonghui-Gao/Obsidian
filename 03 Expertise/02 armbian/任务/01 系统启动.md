· 参考链接:https://jaminzhang.github.io/linux/Linux-boot-process/

arm板中，启动**MMU**以后，编程看见的地址都是虚拟地址，经过MMU以后才是具体的物理地址。在Linux系统启动后，操作系统会把MMU打开，虚拟地址才会出现，否则没有上电之前，跟单片机一样，跑的裸机程序直接对CPU编程。
![[linux引导过程.excalidraw]]

bootloader 内嵌在ROM(?)区的一段启动程序，上电后第一个运行程序的就是bootloader。从0地址开始取地址执行。同时做一些初始化的工作，同时引导从TF卡启动还是eMMC启动还是USB启动，这功能从IROM中地址选择。例如：

| OM[5:1] | 1st Device | 2nd Device |
|:-------:| :-----------: | :----------: |
|  5b'00011       |   eMMC43_CH0          |     USB       |
然后IROM会根管脚设置，(板子开关？)，选择从eMMC中寻找启动程序，如果找不到有效的程序就会中 备用的设备启动如USB TF。

所谓的eMMC就是Flash存储器。
IROM->SROM IRAM->SRAM 类是 nand flash和nor flash
nand flash 和 nor flash 区别：参考 https://news.bangkaow.com/info/202208/361795.html

![[分区结构.excalidraw]]


# Bootloader 的两个阶段
## 单阶段(single Stage)
常用汇编实现，完成一些依赖与CPU体系结构的初始化，并调用出第二阶段的代码。

## 多阶段(Multi Stage)

