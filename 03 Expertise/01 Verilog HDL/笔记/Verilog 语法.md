# 操作符
单目操作符：`a = ~b; //~是单目操作符， b是操作数`
双目操作符：`a = b && c; // &&是双目操作符`
三目操作符：`a = b ? c : d; // ?:是三目操作符`

# 数字声明
## 指明位数的数字
表现形式为：`<size>'<base format><number>`
其中：
`<size>`表明数字的位宽，只能用十进制表示
`<base format>` 包括：十进制('d 或 'D)、 十六进制('h或'H)、二进制('b或'B)
和八进制('o或'O)。
`<number>` 包括：0 1 2 3 4 5 6 7 8 9 1 0 a b c d e f
例如：
`4'b1111` 这是个4位的二进制数
`12'habc` 这是个12位的十六进制数
`16'd255` 这是16位的十进制数

## 不表明位数的数字
默认为十进制数，如果没指定位宽度 默认与仿真器和计算机有关(最小为32位)
`23456` 32位的十进制
`'hc3`  32位的十六进制
`'o21`  32位的八进制
### x和z的值
不确定值用：`x` ；高阻值用：`z`
例如：
`12'h13x` 12位的十六进制 最低四位不确定
`6'hx`      6位的十六进制 所有位置不确定
`32'bz`    32位的高阻值
其中声明：
如16进制为基数`x`或`z`代表4位(${2^4}$)
同理：8进制为基数`x`或`z`代表3位(${2^3}$)
        2进制为基数`x`或`z`代表1位(${2^1}$)
如果某数的最高位是`0`、`x`或`z`，将分别使用`0`或`x`或`z`可以自动对数进行拓展以便填满余下的更高位。
如果是最高位是`1`，使用0拓展余下更高位

## 负数
在位宽的数字前面增加一个减号表示负数
如：
`-6'd3`   //6位的补码形式存储的十进制数3，表示负数
`-6'sd3` //6位的用于符号算术运算的负数
`4'd-2`  //非法说明
### 下划线符号和问号
下划线`_`的作用是提高可读性。如`12'b1111_0000_1000`分隔符
问号`？`是z的另一种表示方式 增强`casez`和`casex`可读性
 
# 字符串
字符串是双引号括起来的一个字符队列，只能在一行中书写，不能包含回车符。Verilog中会将字符串当做一个单字节的ACSII字符队列。
如：`"Hello Verilog World"`

# 标识符和关键字
关键字全为小写，标识符由字母，数字，下划线`_`和美元符`$`组成，区分大小写。第一个字符必须是字母数字或下划线，不能数字或美元符开始。
如：
`reg value` //reg是关键字；value是标识符
`input clk` //input是关键字；clk是标识符

# 数据类型

|  值的级别   | 硬件电路中的条件  |
|  :----:      |             : ----:  |
|      0        | 逻辑0，条件位假 |
|      1         | 逻辑1，条件位真 |
|      x         | 逻辑值不确定 |
|      z         | 高阻，浮动状态 |

## 线网
![[与门.excalidraw]]

线网一般用关键字`wire`声明表示，默认线网的宽度位1。线网的默认值为`z`(`trireg`类型除外，其默认值为x)
例：
```Verilog
wire a;               // 声明电路中a是wire类型
wire b,c;
wire d = 1'b0;     // 声明d被赋值为逻辑0
a = b & c;          //上图电路表示
```

# 寄存器
寄存器表示存储元件，保持原有的数值，直到被改写。这里的寄存器与电路中的寄存器不一样。语法中，`register` 仅仅意味着表示一个保存数值的变量，不需要驱动源，也不需要时钟信号。
关键字为：`reg` 默认为`x` 
例：
``` Verilog
reg reset; 
initial
begin
	reset = 1'b1; //把reset 初始化为1，使数字电路复位
	#100 reset = 1'b0;
end
```

其中`reg`也可以声明带符号(`signed`)类型的变量
例：`reg signed [63:0] m` 

# 向量
线网和寄存器类型的数据默认位宽为1，但是可以声明为向量(大于1)
例：
``` Verilog
wire a;                                // 标量线网变量 默认
wire [7:0] bus;                     // 8位的总线

wire [31:0] busA,busB,busC;  // 3条32位宽的总线
reg lock;                             //标量寄存器，默认
reg [0:40] virtual_addr;         // 41位宽的虚拟地址，向量寄存器
```

向量通过`[high#:low#]`或`[low#:high#]`进行说明，左边表示向量最高的有效位置

## 向量域选择
声明的向量可以通过指定拿某一位或若干个相邻位。
`busA[7]` `bus[2:0]`

### 可变的向量域选择
指定选取向量的部分域，操作符为：起始位可变量，位宽必须是常量
`[<starting_bit> +: width "]` 从起始位开始递增，位宽为`width`
`[<starting_bit> -: width "]` 从起始位开始递减，位宽为`width`
例：
```Verilog
reg [255:0] data1;            //data1[255]是最高位
reg [0:255] data2;           //data2[0]是最高位
reg [7:0] byte;

//用变量选择向量的一部分
byte = data1[31 -: 8];       //从第31位开始，宽度为8 等价data1[31:24]
byte = data1[24 +: 8];      //从第24位开始，宽度为8 等价data1[31:24]
byte = data2[31 -: 8];      //从第31位开始，宽度为8 等价data1[24:31]
byte = data2[24 +: 8];     //从第24位开始，宽度为8 等价data1[24:31]

//循环语句
for(j=0; j<=31; j=j+1)
	byte = data1[(j*8) +: 8];   //次序为[7:0], [15:8], [31:16]...[255:248]

// 初始化向量的一个域
data1[(bytenum*8) +: 8] = 8'b0;    // bytenum=1;则[15:8] 域全为0
```

# 整数、实数和时间寄存器数据类型
## 整数
整数则是有符号数，默认跟主机的字的位数，最小为32
关键字为：`integer`
`integer counter` 一般的变量 用作计数器

## 实数
实常量和实数寄存器数据类型用实数表示，可以用十进制或者科学计数法表示。不能带有范围，其默认值为0。
关键字为：`real`
```Verilog
real delta;
integer i;
delta = 4e10;  //40 000 000
delta = 2.13;
i = delta;       // i = 2，拿到整数部分
```

## 时间寄存器 
使用特殊的时间寄存器数据类型来保存仿真时间(s)，宽度与实现有关，最小为64位
关键字为：`time`
`time save_sim_time` 定义时间类型的变量

# 数组
声明`reg`，`integer`，`time`，`real`，`realtime`及其向量类型的数组，可以声明任意维数的数组。线网数组也可以用于连接实例的端口，数组的每一个元素都可以作为标量或者向量。
形如：`<数组名>[<下标>]`
例：
``` Verilog
integer count [7:0];              //8个计数变量组成的数组
reg bool [31:0];                   //32个布尔寄存器变量组成的数组
reg [4:0] port_id [0:7];         //8个端口标识变量组成的数组，位宽为5
wire w_array1 [7:0] [5:0];      //声明1位线型变量的二位数组
```

向量是一个单独的原件，位宽为n；数组由多个元件组成，其中每个元件的位宽为n或1。
```Verilog
array_4d[0] [0] [0] [0] [15:0] = 0; 
// 把四维数组中索引号为[0] [0] [0] [0]的寄存器型单元的0-15位都置0
```

# 存储器
用寄存器的一位数组表示存储器RAM和ROM。数组的每个元素称为：每个元素和一个字(word)，通过数组来索引，每个字的位宽为1或多位。n个1位的寄存器和一个n位寄存器是不同的。
``` Verilog
reg mem1bit[0:1023];             //1K的1位寄存器
reg [7:0] membyte [0:1023];   //1K的字节(8位)存储器m
membyte[511];                      // 取出地址511所处的字节
```

# 参数
使用参数在模块内定义常数值，参数代表常数
关键字：`parameter`
```Verilog
parameter port_id = 5;                  //定义常熟port_id 为5
parameter cache_line_width = 256 //把宽度设为常熟256
```
通过模块实例化`defparam`语句改变参数值
### 局部参数
关键字`localparam` 作用等同于参数，区别在于它的值不能改变。不能通过`defparam`或命名参数赋值来直接修改。
例：`localparam state1 = 4'b0001`

# 字符串
字符串保存在`reg`类型的变量中，每个字符占用8位(一个字节)。如果寄存器变量的宽度大于字符串的大小，就会用0来填充空余位。如果小于则截去字符串最左边的位。因此声明变量的时候应该要比字符串大一点。
``` Verilog
reg [8*18 : 1] string_value;                 //声明变量 18个字节
string_value = "Hello Verilog World";  
```

|  转义字符   | 显示的字符  |
|  :----:  | :----:  |
| \n  | 换行 |
| \t  | tab |
| % %  | % |
| \ \  | \ |
| \ "  | " |
| \ooo  | 1到3个八进制数字字符 |

# 系统函数和编译指令
## 显示信息
关键字：`$display`
```verilog
$display($time);
$display("ID of the port is %b", port_id);
```

# 监视信息
关键字：`monitor`
```verilog
$monitor($time, 
				 "Value of signals clock = %b reset = %b", clock,reset);
```

# 编译指令
使用方法：`ˋ<keyword>` ˋ<宏名>
```verilog
`define WORD_SIZE 32 
`include header.v
```

